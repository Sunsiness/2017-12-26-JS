<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // 工厂模式
//    function createPerson(name,age) {
//        // 创建一个对象
//        var  obj = {};
//        // 新增键值对
//        obj.name = name;
//        obj.age = age;
//        obj.technology = function () {
//            console.log(name+"会js")
//        };
//        // 把这个对象return出来
//        return obj;
//    };
//    var  p1  = createPerson("王云成",66)
    // 构造函数模式
    function CreatePerson(name,age) {
        // 新增键值对
        console.log(this);// {}

        this.name = name;
        this.age = age;
        this.technology = function () {
            console.log(this.name+"会js")
        };
        return {name:"王明明"};
    };
    var  p1  = new CreatePerson("王云成",66);
    p1.technology()
    var p2 = new CreatePerson("王明明",65);
    p2.technology()
//   console.log(p1 instanceof CreatePerson)
//    console.log(p1);
    // 函数前面被new，那么这个函数就是一个类；或者叫构造函数；
    // 类一定是函数，函数不一定是类；所以函数又可以作为类；

    // 1. 类中this指向当前的实例；
    // 2. 类分为内置类、自定义类
       // 内置类 ：
    //Number : 数字类     String ：字符串类   Boolean : 布尔类
    // Null    Undefined
    // Object ： 对象类  Array : 数组类   RegExp : 正则类  Date  : 时间类

    // Math 不是一个类， Math是对象
    //console.log(Math);

    //3.普通函数： 形成作用域--> 形参赋值---> 变量提升--> 代码从上到下运行--> 作用域销毁
    // 构造函数执行
    // 1). 形成私有作用域
    // 2). 形参赋值
    // 3).变量提升
    // 4). 代码执行之前，默认创建一个空对象，并且让这个作用域中this指向当前这个对象
    // 5).代码从上到下运行
    // 6).代码执行结束，默认把这个对象return出去；

    // 4.如果类不需要传参数，那么后面的小括号可以省略；
//    function Fn() {
//        console.log(this);
//    };
//    var  f = new Fn;
//    console.log(f);

    // 5.如果构造函数中有return，return出一个基本数据类型值，那么不影响返回的实例，那么如果return一个引用数据类型值，那么会把默认的实例给覆盖；

    // 6.instanceof  : 检测一个实例是否属于某个类的方法
    // typeof  : 局限性  1） typeof null -->"object";
    // 2) 不能区分对象数据类型中对象数组正则；
    // 3) 不能检测通过实例创建的变量；都返回“object”
//   var  num = new Number(12);
//    console.log(typeof num);

     //
//    var  ary = new Number(4);
//    console.log(ary instanceof Number)// true
//    console.log(/\d/ instanceof RegExp)// true
   // Array  创建数组时，如果传一个参数，那么这个值是数组的长度，如果传多个参数，参数变成数组的每一项；
//    var  ary  = new Array(13,19);
//    console.log(ary  instanceof  Object);

    // 7.in  : 检测属性是否在对象中存在;不管是公有还是私有属性都返回true；

    var obj = {a:19,b:20};
//    console.log("a" in obj);// true
//    obj.toString()
//    console.log("hasOwnProperty" in obj);// true

//    var  ary = [12,9,10,1,88];
//    ary.push(100).splice(2,2).pop().slice(1);// push 方法的返回值是新数组的长度，不能调用数组原型上splice 方法，所以报错；

    // 8.hasOwnProperty：判断这个属性是否是私有属性
    var obj = {a:19,b:20};
    var  a = {}
//    console.log(obj.hasOwnProperty("a")); // true
//    console.log(obj.hasOwnProperty("toString"));// false
    // for  in  循环遍历对象，只能把对象的私有属性遍历出来；
    function hasPublicProperty(obj,attr) {//
//        if(attr in obj){
//            if(!obj.hasOwnProperty(attr)){
//                return true;
//            }else{
//                return false
//            }
//        }else{
//            return false;
//        }
        return attr in obj && !obj.hasOwnProperty(attr)?true:false;
    };
    console.log(hasPublicProperty(obj, "toString"));// true
    console.log(hasPublicProperty(obj, "a"));// false;


</script>
</body>
</html>