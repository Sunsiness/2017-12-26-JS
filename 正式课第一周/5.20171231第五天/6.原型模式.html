<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    function CreatePerson(name,age) {
        // 新增键值对

        this.name = name;
        this.age = age;
//        this.technology = function () {
//            console.log(this.name+"会js")
//        }
    };
    CreatePerson.prototype.technology = function () {
        console.log(this.name+"会js");
    }
    var  p1  = new CreatePerson("王云成",66);

    console.log(p1);
    p1.technology();
    var p2 = new CreatePerson("王明明",65);
//    p2.technology();

//    var  ary  = [];
    console.log(p1.__proto__.technology===p1.technology);// true// 4
    console.log(p2.name === p1.name);// false
    console.log(p1.technology === p2.__proto__.technology);// true;
    console.log(p1.technology === CreatePerson.prototype.technology);// true
    console.log(p1.technology === CreatePerson.technology);//false
    console.log(p1.constructor === CreatePerson);// true

    //    console.log(CreatePerson instanceof Function);


    // p1首先会看是否是私有属性，如果不是私有属性，会默认通过__proto__继续向上查找；

    // 1. 每一个函数数据类型(普通函数，类（内置类、自定义类）)都天生自带一个prototype属性
    // 2.这个prototype是对象数据类型，它天生自带一个constructor属性；constructor属性值指向当前prototype所对应的那个类；
    // 3.每一个对象数据类型（对象，实例，数组...）都天生自带一个__proto__属性，属性值指向当前实例所属类的原型；
    var  ary = [10];
    ary.push();
    console.log(ary.hasOwn);// undefined

    // 获取对象属性名对应属性值，首先看当前是否是私有属性，如果不是，那么会通过__proto__往上查找，如果父类的原型也没有，那么会通过原型的__proto__继续向上查找，直到找到Object的原型为止，如果Object也没有，那么会输出undefined；这样一级一级往上查找，形成原型链

</script>
</body>
</html>