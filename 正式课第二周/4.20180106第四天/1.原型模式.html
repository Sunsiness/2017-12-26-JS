<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<script>
    // 单例模式
//    var  obj = {name:1};
//    var  obj1 = {name:1};
    // 工厂模式
//    function create() {
//        var obj = {};
//        obj.name = ""
//        return obj;
//    };
//    create();
    // 构造函数模式
//    function Fn() {
//        //var obj = {};   this--> 实例
//        var num =10;
//        if([]==[]){}
//        this.a = "hello"
//        this.getA = function () {
//            console.log(this.a)
//        }
//        // return obj;
//
//    };
//    // Fn 函数一旦被new ，那么Fn就变成一个构造函数，或者一个类
//    var f = new Fn();// 实例是对象数据类型的
//    var  f1 = new Fn();
//    f.getA();
//    f1.getA();

    // 原型模式
    function Fn() {
        //var obj = {};   this--> 实例
        var num =10;
        if([]==[]){}
        this.a = "hello"
//        this.getA = function () {
//            console.log(this.a)
//        }
        // return obj;

    };
//    Fn.prototype.getA = function () { get:hello
//        // this--->f
//        console.log(this.a)
//    }
//    // Fn 函数一旦被new ，那么Fn就变成一个构造函数，或者一个类
    var f = new Fn();// 实例是对象数据类型的
//    var  f1 = new Fn();
//    f.to();
    //    f1.getA();
//    console.log(f);

    // ary
//    var ary = [];
//    ary.pop()

    // 1. 每一个函数数据类型（普通函数、类）都天生自带prototype属性，prototype是一个对象数据类型的
    // 2.prototype天生自带一个constructor属性，constructor属性值指向当前prototype所对应的那个类
    // 3.每一个对象数据类型（对象，数组，实例）都天生自带__proto__属性，属性值指向当前实例所对应的那个类的原型

    // f.toString(),首先查找当前私有属性中有没有toString ，如果没有，那么会通过__proto__继续往上查找，当前当前实例所属类的原型，如果原型也没有，会继续通过__proto__,向上查找，直到找到Object的原型为止，如果这没有，那么会获得undefined；
    var  ary = [12,99,0]
    ary.slice(1,3).splice(0,1).pop().push();

</script>
</body>
</html>